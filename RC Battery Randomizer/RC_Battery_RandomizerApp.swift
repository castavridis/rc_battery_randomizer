//
//  RC_Battery_RandomizerApp.swift
//  RC Battery Randomizer
//
//  Created by C Stavridis on 11/19/25.
//

import SwiftUI
import AppKit

@main
struct RC_Battery_RandomizerApp: App {
    
    // Adapt our custom AppDelegate to hook into SwiftUI life cycle
    // This may be an outdated approach consider using ScenePhase instead
    @NSApplicationDelegateAdaptor(RCBatteryAppDelegate.self) var appDelegate
    
    // We have to add a body to conform to the App protocol
    // But it will be empty because this is a chromeless macOS app
    var body: some Scene {}
    
}

extension NSImage {
    
    // withSmoothOutline was generated by Claude
    func withSmoothOutline(color: NSColor, width: CGFloat) -> NSImage {
        let padding = width * 3
        let newSize = NSSize(
            width: size.width + padding,
            height: size.height + padding
        )
        
        let image = NSImage(size: newSize)
        image.lockFocus()
        
        let center = NSRect(
            x: padding / 2,
            y: padding / 2,
            width: size.width,
            height: size.height
        )
        
        // Draw outline with more steps for smoother result
        let steps = 16  // More steps = smoother outline
        for i in 0..<steps {
            let angle = (2 * .pi / Double(steps)) * Double(i)
            let offsetX = cos(angle) * width
            let offsetY = sin(angle) * width
            
            let offsetRect = NSRect(
                x: center.origin.x + offsetX,
                y: center.origin.y + offsetY,
                width: size.width,
                height: size.height
            )
            
            self.draw(in: offsetRect)
        }
        
        // Tint all the offset copies to create the outline color
        color.setFill()
        NSRect(origin: .zero, size: newSize).fill(using: .sourceAtop)
        
        // Draw the original image on top in the center
        self.draw(in: center)
        
        image.unlockFocus()
        
        return image
    }

    // Static function allows this to be a class-level function instead of instance-level
    static func batteryIcon(percentage: Int) -> NSImage? {
        // PRESENTATION: guard let keyword phrase
        // Doing this makes it so we don't have to pepper baseSymbol? calls all over the place
        guard let baseSymbol = NSImage(systemSymbolName: "battery.0percent", accessibilityDescription: "Battery") else {
            return nil
        }
        let baseConfig = NSImage.SymbolConfiguration(
            pointSize: 19.5,
            weight: .light
        )
        let dimWhite: NSColor = .systemFill.withAlphaComponent(0.75)
        let colorConfig = NSImage.SymbolConfiguration(paletteColors: [dimWhite])
        let combinedConfig = baseConfig.applying(colorConfig)
        guard let configuredSymbol = baseSymbol.withSymbolConfiguration(combinedConfig) else {
            return nil
        }
        let size = configuredSymbol.size
        
        let newImage = NSImage(size: size)
        
        // TODO: Why lockFocus?
        newImage.lockFocus()
        
        NSColor.systemFill.setFill()
        configuredSymbol.draw(at: .zero, from: NSRect(origin: .zero, size: size), operation: .sourceOver, fraction: 1.0)
        
        // TODO: Why defer?
        defer { newImage.unlockFocus() }
        
        // if not charging
        // evaluates to: 4.5 25.0 3.5 8.25 20.5
        let fillStartX = 4.5
        let fillEndX = size.width - 8.0
        let fillY = 3.5
        let fillHeight = size.height - 7.75
        let fillWidth = (fillEndX - fillStartX) * CGFloat(min(100, max(0, percentage))) / 100.0
        
        NSGraphicsContext.current?.saveGraphicsState()
        
        NSColor.white.setFill()
        
        let fillRect = NSRect(x: fillStartX, y: fillY, width: fillWidth, height: fillHeight)
        let path = NSBezierPath(roundedRect: fillRect, xRadius: 2.0, yRadius: 2.0)
        path.addClip() // must add clip before fill otherwise fill will not be clipped
        fillRect.fill()
        
        // There's an approach to sutracting the an NSImage from an NSRect using operation configuredSymbol.draw(in: NSRect(origin: .zero, size: size), from: NSRect(origin: .zero, size: size), operation: .destinationIn, fraction: 1.0)
        
        NSGraphicsContext.current?.restoreGraphicsState()
        
        
        // Attempt to create a charging icon
//        guard let boltOutline = NSImage(systemSymbolName: "bolt.fill", accessibilityDescription: "bolt") else {
//            return nil
//        }
//        let boltOutlineFontConfig = NSImage.SymbolConfiguration(pointSize: 11, weight: .black)
//        let boltOutlineConfig = NSImage.SymbolConfiguration(paletteColors: [NSColor.black])
//        let combinedBoltOutlineConfig = boltOutlineConfig.applying(boltOutlineFontConfig)
//        guard let configuredBoltOutline = boltOutline.withSymbolConfiguration(combinedBoltOutlineConfig) else { return nil }
//        configuredBoltOutline.draw(at: .zero, from: NSRect(origin: CGPoint(x: -9.0, y: 0.5), size: size), operation: .destinationOut, fraction: 1.0)
        
//        let shadow = NSShadow()
//        shadow.shadowColor = .shadowColor
//        shadow.shadowOffset = NSSize(width: 0.0, height: -1.0)
//        shadow.shadowBlurRadius = 1.0
//        shadow.set()
        
        guard let bolt = NSImage(systemSymbolName: "bolt.fill", accessibilityDescription: "bolt") else {
            return nil
        }
        
        let boltConfig = NSImage.SymbolConfiguration(pointSize: 12, weight: .black)
        guard let configuredBolt = bolt.withSymbolConfiguration(boltConfig) else { return nil }
        configuredBolt.withSmoothOutline(color: .green, width: 1.0).draw(at: .zero, from: NSRect(origin: CGPoint(x: -7.125, y: 2.25), size: size), operation: .destinationOut, fraction: 1.0)
        configuredBolt.draw(at: .zero, from: NSRect(origin: CGPoint(x: -8.5, y: 0.75), size: size), operation: .sourceOver, fraction: 1.0)
        
        return newImage
    }
}

class RCBatteryAppDelegate: NSObject, NSApplicationDelegate {
    var statusItem: NSStatusItem?
    var currentLevel: Int = 100
    var timer: Timer?
    
    func generateTitle(button: NSStatusBarButton) -> Void {
        button.font = .menuBarFont(ofSize: 11) // Similar to official battery bar
        button.title = "\(currentLevel)%"
    }
    
    func updateButton(button: NSStatusBarButton) -> Void {
        generateTitle(button: button)
        button.image = NSImage.batteryIcon(percentage: currentLevel)
        button.image?.isTemplate = true // PRESENTATION: Allows image to change color dynamically, have to set everytime the image changes
    }
    
    func updateBatteryLevel(button: NSStatusBarButton) -> Void {
        currentLevel -= 1
        updateButton(button: button)
    }
    
    // PRESENTATION: @objc and #selector why?
    // https://developer.apple.com/documentation/swift/using-objective-c-runtime-features-in-swift
    @objc func handleClick(_ item: String) {
        print("Clicked!")
    }
    
    func createMenu(statusItem: NSStatusItem?) {
        if statusItem == nil { return }
        
        let menu = NSMenu()
        
        let titleItem = NSMenuItem(title: "", action: #selector(handleClick(_:)), keyEquivalent: "")
        titleItem.isEnabled = false
        titleItem.attributedTitle = NSAttributedString(string: "Battery", attributes: [.foregroundColor: NSColor.labelColor, .font: NSFont.systemFont(ofSize: 13, weight: .semibold)]) // PRESENTATION:
        menu.addItem(titleItem)
        
        let subTitleItem = NSMenuItem()
        subTitleItem.action = #selector(self.handleClick(_:))
        subTitleItem.attributedTitle = NSAttributedString(string: "Power Source: Battery", attributes: [.foregroundColor: NSColor.labelColor, .font: NSFont.systemFont(ofSize: 12)])
        menu.addItem(subTitleItem)
        
        menu.addItem(NSMenuItem.separator())
        
        let energyItem = NSMenuItem(title: "", action: nil, keyEquivalent: "")
        energyItem.image = NSImage(systemSymbolName: "battery.100", accessibilityDescription: nil)?.withSymbolConfiguration(NSImage.SymbolConfiguration(pointSize: 17, weight: .regular))
        energyItem.subtitle = "100%"
        menu.addItem(energyItem)
        
        menu.addItem(NSMenuItem.separator())
        
        
        statusItem?.menu = menu
    }
    
    func applicationDidFinishLaunching(_ aNotification: Notification) {
        
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
        if let button = statusItem?.button { // PRESENTATION: if let keyword phrase
            if (timer == nil) {
                timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true, block: { _ in
                    if self.currentLevel > 0 {
                        self.updateBatteryLevel(button: button)
                    } else {
                        self.currentLevel = 100
                        self.timer?.invalidate()
                        self.timer = nil
                    }
                })
            }
            updateButton(button: button)
            button.imagePosition = .imageRight
            button.target = self
        }
        createMenu(statusItem: statusItem)
    }
    
    func applicationWillFinishLaunching(_ notification: Notification) {
        NSApp.setActivationPolicy(.prohibited) // PRESENTATION
    }
}
