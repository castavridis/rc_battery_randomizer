//
//  RC_Battery_RandomizerApp.swift
//  RC Battery Randomizer
//
//  Created by C Stavridis on 11/19/25.
//

import SwiftUI
import AppKit

@main
struct RC_Battery_RandomizerApp: App {
    
    // Adapt our custom AppDelegate to hook into SwiftUI life cycle
    // This may be an outdated approach consider using ScenePhase instead
    @NSApplicationDelegateAdaptor(RCBatteryAppDelegate.self) var appDelegate
    
    // We have to add a body to conform to the App protocol
    // But it will be empty because this is a chromeless macOS app
    var body: some Scene {}
    
}

extension NSImage {
    
    // withSmoothOutline was generated by Claude
    func withSmoothOutline(color: NSColor, width: CGFloat) -> NSImage {
        let padding = width * 3
        let newSize = NSSize(
            width: size.width + padding,
            height: size.height + padding
        )
        
        let image = NSImage(size: newSize)
        image.lockFocus()
        
        let center = NSRect(
            x: padding / 2,
            y: padding / 2,
            width: size.width,
            height: size.height
        )
        
        // Draw outline with more steps for smoother result
        let steps = 16  // More steps = smoother outline
        for i in 0..<steps {
            let angle = (2 * .pi / Double(steps)) * Double(i)
            let offsetX = cos(angle) * width
            let offsetY = sin(angle) * width
            
            let offsetRect = NSRect(
                x: center.origin.x + offsetX,
                y: center.origin.y + offsetY,
                width: size.width,
                height: size.height
            )
            
            self.draw(in: offsetRect)
        }
        
        // Tint all the offset copies to create the outline color
        color.setFill()
        NSRect(origin: .zero, size: newSize).fill(using: .sourceAtop)
        
        // Draw the original image on top in the center
        self.draw(in: center)
        
        image.unlockFocus()
        
        return image
    }

    // Static function allows this to be a class-level function instead of instance-level
    static func batteryIcon(percentage: Int, button: NSStatusBarButton, isCharging: Bool) -> NSImage? {
        let appearanceName = button.effectiveAppearance.name.rawValue
        
        // Default to light mode, it takes a moment for this to update, is it possible to update faster?
        let boltColor: NSColor =
            (appearanceName == "NSAppearanceNameVibrantDark")
                ? NSColor.white
                : NSColor.black
        let batteryColor: NSColor = boltColor.withAlphaComponent(0.65)
        let fillColor: NSColor = (percentage <= 10) ? NSColor.systemRed : boltColor
                
        // PRESENTATION: guard let keyword phrase
        // Doing this makes it so we don't have to pepper baseSymbol? calls all over the place
        guard let baseSymbol = NSImage(systemSymbolName: "battery.0percent", accessibilityDescription: "Battery") else {
            return nil
        }
        let baseConfig = NSImage.SymbolConfiguration(
            pointSize: 19.5,
            weight: .light
        )
        let colorConfig = NSImage.SymbolConfiguration(paletteColors: [batteryColor])
        let combinedConfig = baseConfig.applying(colorConfig)
        guard let configuredSymbol = baseSymbol.withSymbolConfiguration(combinedConfig) else {
            return nil
        }
        let size = configuredSymbol.size
        
        let newImage = NSImage(size: size)
        
        // TODO: Why lockFocus?
        newImage.lockFocus()
        
        fillColor.setFill()
        configuredSymbol.draw(at: .zero, from: NSRect(origin: .zero, size: size), operation: .sourceOver, fraction: 1.0)
        
        // TODO: Why defer?
        defer { newImage.unlockFocus() }
        
        // if not charging
        // evaluates to: 4.5 25.0 3.5 8.25 20.5
        let fillStartX = 4.5
        let fillEndX = size.width - 8.0
        let fillY = 3.5
        let fillHeight = size.height - 7.75
        let fillWidth = (fillEndX - fillStartX) * CGFloat(min(100, max(0, percentage))) / 100.0
        
        NSGraphicsContext.current?.saveGraphicsState()
        
        fillColor.setFill()
        
        let fillRect = NSRect(x: fillStartX, y: fillY, width: fillWidth, height: fillHeight)
        if (percentage > 0) {
            let path = NSBezierPath(roundedRect: fillRect, xRadius: 2.0, yRadius: 2.0)
            path.addClip() // must add clip before fill otherwise fill will not be clipped
        }
        fillRect.fill()
        
        // There's an approach to sutracting the an NSImage from an NSRect using operation configuredSymbol.draw(in: NSRect(origin: .zero, size: size), from: NSRect(origin: .zero, size: size), operation: .destinationIn, fraction: 1.0)
        
        NSGraphicsContext.current?.restoreGraphicsState()
        
        
        // Attempt to create a charging icon
//        guard let boltOutline = NSImage(systemSymbolName: "bolt.fill", accessibilityDescription: "bolt") else {
//            return nil
//        }
//        let boltOutlineFontConfig = NSImage.SymbolConfiguration(pointSize: 11, weight: .black)
//        let boltOutlineConfig = NSImage.SymbolConfiguration(paletteColors: [NSColor.black])
//        let combinedBoltOutlineConfig = boltOutlineConfig.applying(boltOutlineFontConfig)
//        guard let configuredBoltOutline = boltOutline.withSymbolConfiguration(combinedBoltOutlineConfig) else { return nil }
//        configuredBoltOutline.draw(at: .zero, from: NSRect(origin: CGPoint(x: -9.0, y: 0.5), size: size), operation: .destinationOut, fraction: 1.0)
        
//        let shadow = NSShadow()
//        shadow.shadowColor = .shadowColor
//        shadow.shadowOffset = NSSize(width: 0.0, height: -1.0)
//        shadow.shadowBlurRadius = 1.0
//        shadow.set()
        
        if (isCharging) {
            guard let bolt = NSImage(systemSymbolName: "bolt.fill", accessibilityDescription: "bolt") else {
                return nil
            }
            
            let boltFontConfig = NSImage.SymbolConfiguration(pointSize: 10, weight: .black)
            let boltColorConfig = NSImage.SymbolConfiguration(paletteColors: [boltColor])
            let boltConfig = boltFontConfig.applying(boltColorConfig)
            guard let configuredBolt = bolt.withSymbolConfiguration(boltConfig) else { return nil }
            configuredBolt.withSmoothOutline(color: .green, width: 1.0).draw(at: .zero, from: NSRect(origin: CGPoint(x: -7.5, y: 1.5), size: size), operation: .destinationOut, fraction: 1.0)
            configuredBolt.draw(at: .zero, from: NSRect(origin: CGPoint(x: -9.0, y: 0.125), size: size), operation: .sourceOver, fraction: 1.0)
        }
        
        return newImage
    }
}

class RCBatteryAppDelegate: NSObject, NSApplicationDelegate {
    private var observer: Any! // PRESENTATION: set an observer for .effectiveAppearance
    private var sharedObserver: Any!
    var statusItem: NSStatusItem?
    var currentLevel: Int = 100
    var timer: Timer?
    var timerSpeed: Double = 1.0
    var isCharging: Bool = false
    
    func generateTitle(button: NSStatusBarButton) -> Void {
        button.font = .menuBarFont(ofSize: 11) // Similar to official battery bar
        button.title = "\(currentLevel)%"
    }
    
    func updateButton(button: NSStatusBarButton) -> Void {
        generateTitle(button: button)
        button.image = NSImage.batteryIcon(percentage: currentLevel, button: button, isCharging: isCharging)
        // button.image?.isTemplate = true // PRESENTATION: Allows image to change color dynamically, have to set everytime the image changes
        // PRESENTATION .isTemplate is an all or nothing for NSImage
    }
    
    func updateBatteryLevel(button: NSStatusBarButton) -> Void {
        currentLevel -= 1
        updateButton(button: button)
    }
    
    // PRESENTATION: @objc and #selector why?
    // https://developer.apple.com/documentation/swift/using-objective-c-runtime-features-in-swift
    @objc func handleClick(_ sender: NSMenuItem) {
        timerSpeed = 0.25
        currentLevel = 75
    }
    @objc func toggleCharging(_ sender: NSMenuItem) {
        isCharging = !isCharging
        sender.attributedTitle = NSAttributedString(string: isCharging ? "Power Source: Adapter\n2h 31m until fully charged" : "Power Source: Battery", attributes: [.foregroundColor: NSColor.black.withAlphaComponent(0.5), .font: NSFont.systemFont(ofSize: 12)])
    }
        
    func createMenu(statusItem: NSStatusItem?) {
        if statusItem == nil { return }
        
        let menu = NSMenu()
        
        let titleItem = NSMenuItem(title: "", action: #selector(handleClick(_:)), keyEquivalent: "")
        titleItem.isEnabled = false
        titleItem.attributedTitle = NSAttributedString(string: "Battery\t\t\t\t\t\t\t\t", attributes: [.foregroundColor: NSColor.labelColor, .font: NSFont.systemFont(ofSize: 13, weight: .semibold), .baselineOffset: -5]) // PRESENTATION:
        menu.addItem(titleItem)
        
        // Based on my battery
        // 67% = 1h 43m until fully charged
        // 67% = 103 minutes
        // 100% = 154 minutes
        
        let subTitleItem = NSMenuItem()
        subTitleItem.action = #selector(toggleCharging(_:))
        subTitleItem.attributedTitle = NSAttributedString(string: isCharging ? "Power Source: Adapter\n2h 31m until fully charged" : "Power Source: Battery", attributes: [.foregroundColor: NSColor.black.withAlphaComponent(0.5), .font: NSFont.systemFont(ofSize: 12)])
        menu.addItem(subTitleItem)
        
        menu.addItem(NSMenuItem.separator())
        
        let subTitleItem2 = NSMenuItem()
        subTitleItem2.action = #selector(handleClick(_:))
        subTitleItem2.attributedTitle = NSAttributedString(string: "Using significant energy", attributes: [.foregroundColor: NSColor.black.withAlphaComponent(0.5), .font: NSFont.systemFont(ofSize: 12, weight: .semibold)])
        menu.addItem(subTitleItem2)
        
        let subTitleItem3 = NSMenuItem()
        subTitleItem3.action = #selector(handleClick(_:))
        subTitleItem3.image = NSImage(named: "finder_icon")
        subTitleItem3.image?.size = CGSize(width: 17, height: 17)
        subTitleItem3.attributedTitle = NSAttributedString(string: "Finder", attributes: [.foregroundColor: NSColor.black, .font: NSFont.systemFont(ofSize: 13, weight: .regular)])
        menu.addItem(subTitleItem3)
        
        menu.addItem(NSMenuItem.separator())
        
        let subTitleItem4 = NSMenuItem(title: "", action: #selector(handleClick(_:)), keyEquivalent: "")
        subTitleItem4.attributedTitle = NSAttributedString(string: "Battery Settings...", attributes: [.foregroundColor: NSColor.labelColor, .font: NSFont.systemFont(ofSize: 13, weight: .regular)])
        menu.addItem(subTitleItem4)

        statusItem?.menu = menu
    }
    
    func applicationDidFinishLaunching(_ aNotification: Notification) {
        
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
        if let button = statusItem?.button { // PRESENTATION: if let keyword phrase
            if (timer == nil) {
                timer = Timer.scheduledTimer(withTimeInterval: (60.0*4.0/timerSpeed), repeats: true, block: { _ in
                    if self.currentLevel > 0 {
                        self.updateBatteryLevel(button: button)
                    } else {
//                        self.currentLevel = 100
//                        self.timer?.invalidate()
//                        self.timer = nil
                    }
                })
            }
            button.imagePosition = .imageRight
            button.target = self
            observer = button.observe(\.effectiveAppearance) {
                _, _ in self.updateButton(button: button) // PRESENTATION: This change is a little faster but still lags behind the rest of the menu bar
            }
        }
        createMenu(statusItem: statusItem)
    }
    
    func applicationWillFinishLaunching(_ notification: Notification) {
        NSApp.setActivationPolicy(.prohibited) // PRESENTATION
    }
}
